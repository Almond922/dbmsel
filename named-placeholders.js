"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/named-placeholders";
exports.ids = ["vendor-chunks/named-placeholders"];
exports.modules = {

/***/ "(rsc)/./node_modules/named-placeholders/index.js":
/*!**************************************************!*\
  !*** ./node_modules/named-placeholders/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\n\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g,\nDQUOTE = 34,\nSQUOTE = 39,\nBSLASH = 92;\n\nfunction parse(query) {\n  let ppos = RE_PARAM.exec(query);\n  let curpos = 0;\n  let start = 0;\n  let end;\n  const parts = [];\n  let inQuote = false;\n  let escape = false;\n  let qchr;\n  const tokens = [];\n  let qcnt = 0;\n  let lastTokenEndPos = 0;\n  let i;\n\n  if (ppos) {\n    do {\n      for (i=curpos,end=ppos.index; i<end; ++i) {\n        let chr = query.charCodeAt(i);\n        if (chr === BSLASH)\n        escape = !escape;\n        else {\n          if (escape) {\n            escape = false;\n            continue;\n          }\n          if (inQuote && chr === qchr) {\n            if (query.charCodeAt(i + 1) === qchr) {\n              // quote escaped via \"\" or ''\n              ++i;\n              continue;\n            }\n            inQuote = false;\n          } else if (chr === DQUOTE || chr === SQUOTE) {\n            inQuote = true;\n            qchr = chr;\n          }\n        }\n      }\n      if (!inQuote) {\n        parts.push(query.substring(start, end));\n        tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n        start = end + ppos[0].length;\n        lastTokenEndPos = start;\n      }\n      curpos = end + ppos[0].length;\n    } while (ppos = RE_PARAM.exec(query));\n\n    if (tokens.length) {\n      if (curpos < query.length) {\n        parts.push(query.substring(lastTokenEndPos));\n      }\n      return [parts, tokens];\n    }\n  }\n  return [query];\n};\n\nfunction createCompiler(config) {\n  if (!config)\n  config = {};\n  if (!config.placeholder) {\n    config.placeholder = '?';\n  }\n  let ncache = 100;\n  let cache;\n  if (typeof config.cache === 'number') {\n    ncache = config.cache;\n  }\n  if (typeof config.cache === 'object') {\n    cache = config.cache;\n  }\n  if (config.cache !== false && !cache) {\n    cache = ((__webpack_require__(/*! lru.min */ \"(rsc)/./node_modules/lru.min/lib/index.js\").createLRU))({ max: ncache });\n  }\n\n  function toArrayParams(tree, params) {\n    const arr = [];\n    if (tree.length == 1) {\n      return [tree[0], []];\n    }\n\n    if (typeof params == 'undefined')\n      throw new Error('Named query contains placeholders, but parameters object is undefined');\n\n    const tokens = tree[1];\n    for (let i=0; i < tokens.length; ++i) {\n      arr.push(params[tokens[i]]);\n    }\n    return [tree[0], arr];\n  }\n\n  function noTailingSemicolon(s) {\n    if (s.slice(-1) == ':') {\n      return s.slice(0, -1);\n    }\n    return s;\n  }\n\n  function join(tree) {\n    if (tree.length == 1) {\n      return tree;\n    }\n\n    let unnamed = noTailingSemicolon(tree[0][0]);\n    for (let i=1; i < tree[0].length; ++i) {\n      if (tree[0][i-1].slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n      unnamed += config.placeholder;\n      unnamed += noTailingSemicolon(tree[0][i]);\n    }\n\n    const last = tree[0][tree[0].length -1];\n    if (tree[0].length == tree[1].length) {\n      if (last.slice(-1) == ':') {\n        unnamed += config.placeholder;\n      }\n      unnamed += config.placeholder;\n    }\n    return [unnamed, tree[1]];\n  }\n\n  function compile(query, paramsObj) {\n    let tree;\n    if (cache && (tree = cache.get(query))) {\n      return toArrayParams(tree, paramsObj)\n    }\n    tree = join(parse(query));\n    if(cache) {\n      cache.set(query, tree);\n    }\n    return toArrayParams(tree, paramsObj);\n  }\n\n  compile.parse = parse;\n  return compile;\n}\n\n// named :one :two to postgres-style numbered $1 $2 $3\nfunction toNumbered(q, params) {\n  const tree = parse(q);\n  const paramsArr = [];\n  if (tree.length == 1) {\n    return [tree[0], paramsArr];\n  }\n\n  const pIndexes = {};\n  let pLastIndex = 0;\n  let qs = '';\n  let varIndex;\n  const varNames = [];\n  for (let i=0; i < tree[0].length; ++i) {\n    varIndex = pIndexes[tree[1][i]];\n    if (!varIndex) {\n      varIndex = ++pLastIndex;\n      pIndexes[tree[1][i]] = varIndex;\n    }\n    if (tree[1][i]) {\n      varNames[varIndex - 1] = tree[1][i];\n      qs += tree[0][i] + '$' + varIndex;\n    } else {\n      qs += tree[0][i];\n    }\n  }\n  return [qs, varNames.map(n => params[n])];\n}\n\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmFtZWQtcGxhY2Vob2xkZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJGQUE0QixJQUFJLGFBQWE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXEFrc2hheWFcXGRibXNlbFxcbm9kZV9tb2R1bGVzXFxuYW1lZC1wbGFjZWhvbGRlcnNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gYmFzZWQgb24gY29kZSBmcm9tIEJyaWFuIFdoaXRlIEBtc2NkZXggbWFyaWFzcWwgbGlicmFyeSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9tc2NkZXgvbm9kZS1tYXJpYXNxbC9ibG9iL21hc3Rlci9saWIvQ2xpZW50LmpzI0wyNzItTDMzMlxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL21zY2RleC9ub2RlLW1hcmlhc3FsL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxuY29uc3QgUkVfUEFSQU0gPSAvKD86XFw/KXwoPzo6KFxcZCt8KD86W2EtekEtWl1bYS16QS1aMC05X10qKSkpL2csXG5EUVVPVEUgPSAzNCxcblNRVU9URSA9IDM5LFxuQlNMQVNIID0gOTI7XG5cbmZ1bmN0aW9uIHBhcnNlKHF1ZXJ5KSB7XG4gIGxldCBwcG9zID0gUkVfUEFSQU0uZXhlYyhxdWVyeSk7XG4gIGxldCBjdXJwb3MgPSAwO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBsZXQgaW5RdW90ZSA9IGZhbHNlO1xuICBsZXQgZXNjYXBlID0gZmFsc2U7XG4gIGxldCBxY2hyO1xuICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgbGV0IHFjbnQgPSAwO1xuICBsZXQgbGFzdFRva2VuRW5kUG9zID0gMDtcbiAgbGV0IGk7XG5cbiAgaWYgKHBwb3MpIHtcbiAgICBkbyB7XG4gICAgICBmb3IgKGk9Y3VycG9zLGVuZD1wcG9zLmluZGV4OyBpPGVuZDsgKytpKSB7XG4gICAgICAgIGxldCBjaHIgPSBxdWVyeS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hyID09PSBCU0xBU0gpXG4gICAgICAgIGVzY2FwZSA9ICFlc2NhcGU7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpblF1b3RlICYmIGNociA9PT0gcWNocikge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5LmNoYXJDb2RlQXQoaSArIDEpID09PSBxY2hyKSB7XG4gICAgICAgICAgICAgIC8vIHF1b3RlIGVzY2FwZWQgdmlhIFwiXCIgb3IgJydcbiAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gRFFVT1RFIHx8IGNociA9PT0gU1FVT1RFKSB7XG4gICAgICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHFjaHIgPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWluUXVvdGUpIHtcbiAgICAgICAgcGFydHMucHVzaChxdWVyeS5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgICAgICB0b2tlbnMucHVzaChwcG9zWzBdLmxlbmd0aCA9PT0gMSA/IHFjbnQrKyA6IHBwb3NbMV0pO1xuICAgICAgICBzdGFydCA9IGVuZCArIHBwb3NbMF0ubGVuZ3RoO1xuICAgICAgICBsYXN0VG9rZW5FbmRQb3MgPSBzdGFydDtcbiAgICAgIH1cbiAgICAgIGN1cnBvcyA9IGVuZCArIHBwb3NbMF0ubGVuZ3RoO1xuICAgIH0gd2hpbGUgKHBwb3MgPSBSRV9QQVJBTS5leGVjKHF1ZXJ5KSk7XG5cbiAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgaWYgKGN1cnBvcyA8IHF1ZXJ5Lmxlbmd0aCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHF1ZXJ5LnN1YnN0cmluZyhsYXN0VG9rZW5FbmRQb3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbcGFydHMsIHRva2Vuc107XG4gICAgfVxuICB9XG4gIHJldHVybiBbcXVlcnldO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIoY29uZmlnKSB7XG4gIGlmICghY29uZmlnKVxuICBjb25maWcgPSB7fTtcbiAgaWYgKCFjb25maWcucGxhY2Vob2xkZXIpIHtcbiAgICBjb25maWcucGxhY2Vob2xkZXIgPSAnPyc7XG4gIH1cbiAgbGV0IG5jYWNoZSA9IDEwMDtcbiAgbGV0IGNhY2hlO1xuICBpZiAodHlwZW9mIGNvbmZpZy5jYWNoZSA9PT0gJ251bWJlcicpIHtcbiAgICBuY2FjaGUgPSBjb25maWcuY2FjaGU7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb25maWcuY2FjaGUgPT09ICdvYmplY3QnKSB7XG4gICAgY2FjaGUgPSBjb25maWcuY2FjaGU7XG4gIH1cbiAgaWYgKGNvbmZpZy5jYWNoZSAhPT0gZmFsc2UgJiYgIWNhY2hlKSB7XG4gICAgY2FjaGUgPSAocmVxdWlyZSgnbHJ1Lm1pbicpLmNyZWF0ZUxSVSkoeyBtYXg6IG5jYWNoZSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQXJyYXlQYXJhbXModHJlZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgaWYgKHRyZWUubGVuZ3RoID09IDEpIHtcbiAgICAgIHJldHVybiBbdHJlZVswXSwgW11dO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lZCBxdWVyeSBjb250YWlucyBwbGFjZWhvbGRlcnMsIGJ1dCBwYXJhbWV0ZXJzIG9iamVjdCBpcyB1bmRlZmluZWQnKTtcblxuICAgIGNvbnN0IHRva2VucyA9IHRyZWVbMV07XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgdG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcnIucHVzaChwYXJhbXNbdG9rZW5zW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBbdHJlZVswXSwgYXJyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vVGFpbGluZ1NlbWljb2xvbihzKSB7XG4gICAgaWYgKHMuc2xpY2UoLTEpID09ICc6Jykge1xuICAgICAgcmV0dXJuIHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGpvaW4odHJlZSkge1xuICAgIGlmICh0cmVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBsZXQgdW5uYW1lZCA9IG5vVGFpbGluZ1NlbWljb2xvbih0cmVlWzBdWzBdKTtcbiAgICBmb3IgKGxldCBpPTE7IGkgPCB0cmVlWzBdLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodHJlZVswXVtpLTFdLnNsaWNlKC0xKSA9PSAnOicpIHtcbiAgICAgICAgdW5uYW1lZCArPSBjb25maWcucGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgICB1bm5hbWVkICs9IGNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICAgIHVubmFtZWQgKz0gbm9UYWlsaW5nU2VtaWNvbG9uKHRyZWVbMF1baV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3QgPSB0cmVlWzBdW3RyZWVbMF0ubGVuZ3RoIC0xXTtcbiAgICBpZiAodHJlZVswXS5sZW5ndGggPT0gdHJlZVsxXS5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0LnNsaWNlKC0xKSA9PSAnOicpIHtcbiAgICAgICAgdW5uYW1lZCArPSBjb25maWcucGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgICB1bm5hbWVkICs9IGNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIFt1bm5hbWVkLCB0cmVlWzFdXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUocXVlcnksIHBhcmFtc09iaikge1xuICAgIGxldCB0cmVlO1xuICAgIGlmIChjYWNoZSAmJiAodHJlZSA9IGNhY2hlLmdldChxdWVyeSkpKSB7XG4gICAgICByZXR1cm4gdG9BcnJheVBhcmFtcyh0cmVlLCBwYXJhbXNPYmopXG4gICAgfVxuICAgIHRyZWUgPSBqb2luKHBhcnNlKHF1ZXJ5KSk7XG4gICAgaWYoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnNldChxdWVyeSwgdHJlZSk7XG4gICAgfVxuICAgIHJldHVybiB0b0FycmF5UGFyYW1zKHRyZWUsIHBhcmFtc09iaik7XG4gIH1cblxuICBjb21waWxlLnBhcnNlID0gcGFyc2U7XG4gIHJldHVybiBjb21waWxlO1xufVxuXG4vLyBuYW1lZCA6b25lIDp0d28gdG8gcG9zdGdyZXMtc3R5bGUgbnVtYmVyZWQgJDEgJDIgJDNcbmZ1bmN0aW9uIHRvTnVtYmVyZWQocSwgcGFyYW1zKSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZShxKTtcbiAgY29uc3QgcGFyYW1zQXJyID0gW107XG4gIGlmICh0cmVlLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIFt0cmVlWzBdLCBwYXJhbXNBcnJdO1xuICB9XG5cbiAgY29uc3QgcEluZGV4ZXMgPSB7fTtcbiAgbGV0IHBMYXN0SW5kZXggPSAwO1xuICBsZXQgcXMgPSAnJztcbiAgbGV0IHZhckluZGV4O1xuICBjb25zdCB2YXJOYW1lcyA9IFtdO1xuICBmb3IgKGxldCBpPTA7IGkgPCB0cmVlWzBdLmxlbmd0aDsgKytpKSB7XG4gICAgdmFySW5kZXggPSBwSW5kZXhlc1t0cmVlWzFdW2ldXTtcbiAgICBpZiAoIXZhckluZGV4KSB7XG4gICAgICB2YXJJbmRleCA9ICsrcExhc3RJbmRleDtcbiAgICAgIHBJbmRleGVzW3RyZWVbMV1baV1dID0gdmFySW5kZXg7XG4gICAgfVxuICAgIGlmICh0cmVlWzFdW2ldKSB7XG4gICAgICB2YXJOYW1lc1t2YXJJbmRleCAtIDFdID0gdHJlZVsxXVtpXTtcbiAgICAgIHFzICs9IHRyZWVbMF1baV0gKyAnJCcgKyB2YXJJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXMgKz0gdHJlZVswXVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtxcywgdmFyTmFtZXMubWFwKG4gPT4gcGFyYW1zW25dKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ29tcGlsZXI7XG5tb2R1bGUuZXhwb3J0cy50b051bWJlcmVkID0gdG9OdW1iZXJlZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/named-placeholders/index.js\n");

/***/ })

};
;